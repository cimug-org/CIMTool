<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="3.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:a="http://langdale.com.au/2005/Message#"
    xmlns:sawsdl="http://www.w3.org/ns/sawsdl"
    xmlns="http://langdale.com.au/2009/Indent"
    exclude-result-prefixes="a">
<!--
   Revised CIMTOOL C# Class Generator with Properties
   This XSLT generates class declarations (names) along with:
     - A default (parameterless) constructor
     - A ToString() override
     - Auto-implemented properties for attributes and associations
   Licensed under the Apache License, Version 2.0.
-->
    <xsl:output indent="yes" method="xml" encoding="utf-8" />
   
    <!-- Parameters -->
    <xsl:param name="version"/>
    <xsl:param name="baseURI"/>
    <xsl:param name="envelope">Profile</xsl:param>
    <xsl:param name="package">au.com.langdale.cimtool.generated</xsl:param>
    <xsl:param name="mridType">string</xsl:param>
   
    <!-- Template: Convert xstype to C# type -->
    <xsl:template name="type">
        <xsl:param name="xstype" select="@xstype"/>
        <xsl:choose>
            <xsl:when test="$xstype = 'string'">string</xsl:when>
            <xsl:when test="$xstype = 'integer' or $xstype = 'int'">int</xsl:when>
            <xsl:when test="$xstype = 'float'">double</xsl:when>
            <xsl:when test="$xstype = 'double'">double</xsl:when>
            <xsl:when test="$xstype = 'boolean'">bool</xsl:when>
            <xsl:otherwise>string</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
   
    <!-- Variables for string transformation -->
    <xsl:variable name="lc">abcdefghijklmnopqrstuvwxyz</xsl:variable>
    <xsl:variable name="uc">ABCDEFGHIJKLMNOPQRSTUVWXYZ</xsl:variable>
   
    <!-- Template: Capitalise a name -->
    <xsl:template name="capitalise">
        <xsl:param name="name" select="@name"/>
        <xsl:variable name="clean" select="translate($name, '-', '_')"/>
        <xsl:value-of select="concat(translate(substring($clean,1,1), $lc, $uc), substring($clean,2))"/>
    </xsl:template>

   
    <!-- Top-level Catalog template -->
    <xsl:template match="a:Catalog">
        <document>
            <item>using System;</item>
            <item>using System.ComponentModel.DataAnnotations;</item>
            <item>using System.ComponentModel.DataAnnotations.Schema;</item>
            <item>using System.Collections.Generic;</item>
            <list begin="/**" indent=" * " end=" */">
                <item>Annotated C# for <xsl:value-of select="$envelope"/></item>
                <item>Generated by CIMTool https://cimtool.ucaiug.io [cimtool.ucaiug.io]</item>
            </list>
            <item>public class <xsl:value-of select="$envelope"/></item>
            <list begin="{{" indent="       " end="}}">
                <!-- Generate class declarations for ComplexType, Root and EnumeratedType -->
                <xsl:apply-templates select="a:ComplexType|a:Root|a:EnumeratedType"/>
                <xsl:call-template name="config"/>
            </list>
        </document>
    </xsl:template>
   
    <!-- Class template for ComplexType and Root with properties -->
    <xsl:template match="a:ComplexType|a:Root">
        <xsl:variable name="super" select="a:SuperType[1]"/>
        <item>[Table(&quot;<xsl:value-of select="@name"/>&quot;)]</item>
        <item>
            public class <xsl:value-of select="@name"/>
            <xsl:if test="$super">
                <xsl:text> : </xsl:text>
                <xsl:value-of select="$super/@name"/>
            </xsl:if>
            {
        </item>
        <xsl:if test="$super">
            <item>    // Inherits from <xsl:value-of select="$super/@name"/> - configure further in EF Fluent API if needed</item>
        </xsl:if>
        <list begin="" indent="    " end="">
            <item>public <xsl:value-of select="@name"/>() { }</item>
            <item> </item>
            <item>public override string ToString() { return this.GetType().Name; }</item>
            <item> </item>
            <xsl:apply-templates select="a:Simple|a:Domain|a:Instance|a:Reference|a:Enumerated"/>
        </list>
        <item>}</item>
    </xsl:template>

    <!-- Class template for EnumeratedType with properties -->
    <xsl:template match="a:EnumeratedType">
        <sp/>
        <item>[Table(&quot;<xsl:value-of select="@name"/>&quot;)]</item>
        <item>public class <xsl:value-of select="@name"/> {</item>
        <!-- Default constructor -->
        <item>    public <xsl:value-of select="@name"/>() { }</item>
        <!-- ToString override -->
        <item>    public override string ToString() { return this.GetType().Name; }</item>
        <!-- Generate enumerated values as constant properties -->
        <xsl:apply-templates select="a:EnumeratedValue"/>
        <item>}</item>
    </xsl:template>
   
    <!-- Configuration block listing all classes -->
    <xsl:template name="config">
        <sp/>
        <item>public static readonly System.Type[] allClasses = new System.Type[]</item>
        <list begin="{{" indent="    " delim="," end="}};">
            <xsl:apply-templates select="a:ComplexType|a:Root|a:EnumeratedType" mode="config"/>
        </list>
    </xsl:template>
   
    <!-- In config mode: output each class reference using typeof(...) -->
    <xsl:template match="a:ComplexType|a:Root|a:EnumeratedType" mode="config">
        <item>typeof(<xsl:value-of select="@name"/>)</item>
    </xsl:template>
   
    <!-- Property template for a:Simple and a:Domain (simple attributes) -->
    <xsl:template match="a:Simple|a:Domain">
        <item>    [Column(&quot;<xsl:value-of select="@name"/>&quot;)]</item>
        <item>    public <xsl:call-template name="type">
                    <xsl:with-param name="xstype" select="@xstype"/>
        </xsl:call-template><xsl:text> </xsl:text>
                <xsl:call-template name="capitalise">
                    <xsl:with-param name="name" select="@name"/>
                </xsl:call-template> { get; set; }</item>
    </xsl:template>
   
    <!-- Property template for a:Instance and a:Reference (navigation properties) -->
    <xsl:template match="a:Instance|a:Reference">
        <xsl:choose>
            <!-- Single property when maxOccurs is missing or equals '1' -->
            <xsl:when test="not(@maxOccurs) or @maxOccurs = '1'">
                <item>    [ForeignKey(&quot;<xsl:value-of select="@name"/>&quot;)]</item>
                <item>    public virtual <xsl:value-of select="@type"/>  <xsl:text> </xsl:text>
                        <xsl:call-template name="capitalise">
                            <xsl:with-param name="name" select="@name"/>
                        </xsl:call-template> { get; set; }</item>
            </xsl:when>
            <!-- Otherwise, generate a collection property -->
            <xsl:otherwise>
                <item>    [ForeignKey(&quot;<xsl:value-of select="@name"/>&quot;)]</item>
                <item>    public virtual ICollection&lt;<xsl:value-of select="@type"/>&gt;
                        <xsl:call-template name="capitalise">
                            <xsl:with-param name="name" select="@name"/>
                        </xsl:call-template> { get; set; }</item>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <!-- Property template for a:Enumerated (enumerated property as a string) -->
    <xsl:template match="a:Enumerated">
        <item>    [Column(&quot;<xsl:value-of select="@name"/>&quot;)]</item>
        <item>    public string
                    <xsl:call-template name="capitalise">
                        <xsl:with-param name="name" select="@name"/>
                    </xsl:call-template> { get; set; }</item>
    </xsl:template>
   
    <!-- Template for enumerated values inside an EnumeratedType -->
    <xsl:template match="a:EnumeratedValue">
        <item>    public const string
                    <xsl:call-template name="capitalise">
                        <xsl:with-param name="name" select="@name"/>
                    </xsl:call-template> = &quot;<xsl:value-of select="@name"/>&quot;;</item>
    </xsl:template>
   
    <!-- Suppress text nodes -->
    <xsl:template match="text()"/>
    <xsl:template match="node()" mode="config"/>
    <xsl:template match="node()" mode="annotate"/>
   
</xsl:stylesheet>

