<?xml version="1.0" encoding="UTF-8"?>
<!--
  Copyright 2024 UCAIug

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

  See the License for the specific language governing permissions and
  limitations under the License.
-->
<xsl:stylesheet version="2.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:a="http://langdale.com.au/2005/Message#"
	xmlns:sawsdl="http://www.w3.org/ns/sawsdl"
	xmlns="http://langdale.com.au/2009/Indent">

	<xsl:output indent="yes" method="xml" encoding="utf-8" />
	<xsl:param name="version"/>
	<xsl:param name="baseURI"/>
	<xsl:param name="envelope">Profile</xsl:param>

	<xsl:template name="ident">
		<xsl:param name="name" select="@name"/>
		<xsl:text>"</xsl:text><xsl:value-of select="$name"/><xsl:text>"</xsl:text>
	</xsl:template>
	
	<!-- NOTE: CHAR VARYING (or CHARACTER VARYING) is the ANSI SQL standard term. The more 
		 commonly known equivalent type is VARCHAR which is what has been used here. Here
		 the type corresponds to an assumed UUID. This relevant for mRID and ID PKs -->
	<xsl:param name="uuidType">VARCHAR(36)</xsl:param>

	<xsl:template name="type">
		<xsl:param name="name" select="@name"/>
		<xsl:text> </xsl:text>
		<xsl:choose>
			<xsl:when test="@xstype = 'string' and $name = 'mRID'">VARCHAR(36)</xsl:when>
			<xsl:when test="@xstype = 'string'">VARCHAR(255)</xsl:when>
			<xsl:when test="@xstype = 'normalizedsString'">VARCHAR(255)</xsl:when>
			<xsl:when test="@xstype = 'token'">VARCHAR(255)</xsl:when>
			<!-- The 2,048-character limit is widely considered a safe maximum for URLs in 
			     practice, especially due to legacy compatibility with Internet Explorer. -->
			<xsl:when test="@xstype = 'anyURI' ">VARCHAR(2048)</xsl:when>
			<!-- short is a 16-bit signed integer -->
			<xsl:when test="@xstype = 'short'">SMALLINT</xsl:when>
			<!-- Below is a 32-bit signed integer -->
			<!-- INTEGER is a standard exact numeric type defined in the ANSI    -->
			<!-- SQL standard (SQL-92) as a 32-bit integer.                      -->
			<!-- Represents: whole numbers from -2,147,483,648 to +2,147,483,647 -->
			<!-- Equivalent to: NUMERIC(p, 0) with p roughly <= 10               -->
			<xsl:when test="@xstype = 'integer' or @xstype = 'int'">INTEGER</xsl:when>
			<!-- long is a 64-bit signed integer -->
			<xsl:when test="@xstype = 'long'">BIGINT</xsl:when>
			<!--  Binary encoded in base64 -->
			<xsl:when test="@xstype = 'base64Binary'">BLOB</xsl:when>
			<!--  Binary encoded in hex -->
			<xsl:when test="@xstype = 'hexBinary'">BLOB</xsl:when>
			<xsl:when test="@xstype = 'decimal'">DOUBLE PRECISION</xsl:when>
			<xsl:when test="@xstype = 'float'">DOUBLE PRECISION</xsl:when>
			<xsl:when test="@xstype = 'double'">DOUBLE PRECISION</xsl:when>
			<xsl:when test="@xstype = 'date'">DATE</xsl:when>
			<xsl:when test="@xstype = 'time'">TIME</xsl:when>
			<xsl:when test="@xstype = 'dateTime'">TIMESTAMP</xsl:when>
			<!-- Below is a common approach for representing a boolean types across all common databases. -->
			<xsl:when test="@xstype = 'boolean'">INTEGER NOT NULL DEFAULT 1 CHECK (<xsl:value-of select="$name"/> IN (0, 1))</xsl:when>
			<xsl:otherwise>VARCHAR(255)</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="notnull">
		<xsl:if test="@minOccurs > 0"> NOT NULL</xsl:if>
	</xsl:template>
 
	<xsl:template match="a:Catalog">
		<!--  the top level template  -->
		<document>
			<item>-- ==========================================================================================</item>
			<list indent="-- ">
				<item>ANSI-SQL-92 compliant schema for <xsl:value-of select="$envelope" /></item>
				<item>Generated by CIMTool https://cimtool.ucaiug.io</item>
				<item/>
				<item>Compound types are represented as separate 1:1 tables and enforces via</item>
				<item>a combination of the use of both UNIQUE on columns that reference tables</item>
				<item>representing Compound types and corresponding FK column constraint</item>
				<item>definitions to those tables.</item>
				<item/>
				<item>Though Compounds do not have an "mRID" and do not inherantly represent</item>
				<item>persistent objects in the CIM (i.e. are inherited from IdentifiedObject)</item>
				<item>they are here given a unique identifier "id" that is distinct from "mRID"</item>
				<item>and used for persistence purposes.</item>
				<item/>				
				<item>Tables that represent Compound types in the CIM are not normalized for</item>
				<item>the following reasons:</item>
				<item/>
			</list>
			<list indent="--   ">
				<item>Normalization, particularly to 3NF, typically requires:</item>
			</list>
			<list indent="--     ">
				<item>No repeating groups.</item>
				<item>No partial or transitive dependencies.</item>
				<item>Every non-key attribute must depend only on the whole key.</item>
				<item/>	
			</list>		
			<list indent="--   ">
				<item>But compound classes in the CIM domain:</item>
			</list>
			<list indent="--     ">
				<item>Do not have surrogate or natural primary keys derived from business rules.</item>
				<item>Are logically value objects: any change to any attribute means the value is distinct.</item>
				<item>Have implicit semantic atomicity — they’re treated as indivisible chunks.</item>
				<item/>
			</list>
			<item>-- ==========================================================================================</item>
			<item>--</item>
		    <xsl:apply-templates/>
			<item/>
			<item>------------------------------------------------------------------------------</item>
		    <item>-- Inheritance constraint definitions</item>
		    <item>------------------------------------------------------------------------------</item>
		    <xsl:apply-templates mode="inheritance-constraints"/>
			<item/>
			<item>------------------------------------------------------------------------------</item>
		    <item>-- Standard foreign key constraint definitions</item>
		    <item>------------------------------------------------------------------------------</item>
		    <xsl:apply-templates mode="constraints"/>
		    <item/>
		    <item>------------------------------------------------------------------------------</item>
		    <item>-- Cascade delete foreign key constraint definitions (for Compounds)</item>
		    <item>------------------------------------------------------------------------------</item>
		    <item/>
		    <list indent="-- ">
				<item>The following cascade delete constraints are defined in order to</item>
				<item>support deletion of child table records for tables containing</item>
				<item>Compound data. Such child data will be deleted concurrently to</item>
				<item>that of its parent data.</item>
			</list>
		    <xsl:apply-templates mode="cascade-constraints"/>
		    <item/>
		    <item>------------------------------------------------------------------------------</item>
		    <item>-- Foreign key column indexes for optimized queries and joins</item>
		    <item>------------------------------------------------------------------------------</item>
		    <item/>
		    <xsl:apply-templates mode="fk-indexes"/>
		</document>
	</xsl:template>
	
	<xsl:template match="a:Root|a:ComplexType|a:CompoundType">
		<!-- a table -->
		<item/>
		<xsl:call-template name="annotate" />
		<item>CREATE TABLE <xsl:call-template name="ident"/></item>
		<list begin="(" indent="    " delim="," end=");"> 
		    <item><xsl:choose><xsl:when test="self::a:CompoundType"> "id" </xsl:when><xsl:otherwise> "mRID" </xsl:otherwise></xsl:choose><xsl:value-of select="$uuidType"/> PRIMARY KEY</item>
		    <xsl:apply-templates/>
		</list>
	</xsl:template>
	
	<xsl:template match="a:EnumeratedType">
		<!-- a reference table for an enumeration -->
		<item/>
		<xsl:call-template name="annotate" />
		<item>
		    CREATE TABLE <xsl:call-template name="ident"/>
		    ( "name" VARCHAR(50) UNIQUE );
		</item>    

		<xsl:variable name="name" select="@name"/>
		<xsl:for-each select="a:EnumeratedValue">
			<!-- inserts one value into a reference table -->
			<xsl:call-template name="annotate" />
			<item>
				INSERT INTO 
    		    <xsl:call-template name="ident">
    			    <xsl:with-param name="name" select="$name"/>
    		    </xsl:call-template> 
			    ( "name" ) VALUES ( '<xsl:value-of select="@name"/>' );
			</item>
		</xsl:for-each>
	</xsl:template>
	
	<xsl:template match="a:Instance|a:Reference|a:Compound">
		<xsl:if test="not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID'">
			<!-- a foreign key column -->
			<decorate>
				<item>-- FK column reference to table "<xsl:value-of select="@type"/>"</item>
				<xsl:call-template name="annotate" />
				<item>
					<xsl:call-template name="ident"/>
					<xsl:text> </xsl:text>
					<xsl:value-of select="$uuidType"/>
					<xsl:if test="self::a:Compound"> 
						UNIQUE 
					</xsl:if>
					<xsl:call-template name="notnull"/> 
				</item>
			</decorate>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="a:Root[a:SuperType]|a:ComplexType[a:SuperType]" mode="inheritance-constraints" >
		<item/>
		<item>-- Inheritance subclass-superclass constraint for table "<xsl:value-of select="@name"/>"</item>
		<xsl:apply-templates mode="inheritance-constraints"/>
	</xsl:template>
	
	<xsl:template match="a:SuperType" mode="inheritance-constraints">
		<item>
		    ALTER TABLE 
			<xsl:call-template name="ident">
		        <xsl:with-param name="name" select="../@name"/>
			</xsl:call-template>
		    ADD FOREIGN KEY ( "mRID" ) REFERENCES 
		    <xsl:call-template name="ident"/>
		    ( "mRID" );
		</item> 
	</xsl:template>
	
	<xsl:template match="a:Root|a:ComplexType|a:CompoundType" mode="constraints" >
		<xsl:if test="a:Instance[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']
					 |a:Reference[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']
					 |a:Compound[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']">
			<item/>
			<item>-- Foreign keys for table "<xsl:value-of select="@name"/>"</item>
			<xsl:apply-templates mode="constraints"/>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="a:Root|a:ComplexType|a:CompoundType" mode="cascade-constraints" >
		<xsl:if test="a:Instance[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']
					 |a:Reference[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']
					 |a:Compound[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']">
			<item/>
			<item>-- Cascade deletes for compounds referenced in table "<xsl:value-of select="@name"/>"</item>
			<xsl:apply-templates mode="cascade-constraints"/>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="a:Root|a:ComplexType|a:CompoundType" mode="fk-indexes" >
		<xsl:if test="a:Instance[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']
					 |a:Reference[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']
					 |a:Compound[not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID']">
			<xsl:apply-templates mode="fk-indexes"/>
		</xsl:if>
	</xsl:template>

	<xsl:template match="a:Instance|a:Reference|a:Compound" mode="constraints">
		<xsl:if test="not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID'">
			<item>
				ALTER TABLE
				<xsl:call-template name="ident">
					<xsl:with-param name="name" select="../@name"/>
				</xsl:call-template>
				ADD FOREIGN KEY ( <xsl:call-template name="ident"/> ) 
				REFERENCES   
				<xsl:call-template name="ident">
					<xsl:with-param name="name" select="@type"/>
				</xsl:call-template> 
				<xsl:choose>
					<xsl:when test="self::a:Compound">
						( "id" );
					</xsl:when>
					<xsl:otherwise>
						( "mRID" );
					</xsl:otherwise>
				</xsl:choose>
			</item> 
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="a:Compound" mode="cascade-constraints">
		<xsl:if test="not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID'">
			<xsl:variable name="fkTable" select="@type"/>
			<xsl:variable name="cascadeColumn" select="../@name"/>
			<item>
				ALTER TABLE
				<xsl:call-template name="ident">
					<xsl:with-param name="name" select="@type"/>
				</xsl:call-template> 
				ADD CONSTRAINT <xsl:value-of select="concat('fk_', $fkTable, '_', $cascadeColumn)"/> 
				FOREIGN KEY ( "id" ) REFERENCES 
				<xsl:call-template name="ident">
					<xsl:with-param name="name" select="../@name"/>
				</xsl:call-template> 
				( <xsl:call-template name="ident"/> )
				ON DELETE CASCADE;
			</item> 
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="a:Instance|a:Reference|a:Compound" mode="fk-indexes">
		<xsl:if test="not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID'">
			<xsl:variable name="fkTable" select="../@name"/>
			<xsl:variable name="indexedColumn" select="@name"/>
			<item>
				CREATE INDEX 
				<xsl:value-of select="concat('ix_', $fkTable, '_', $indexedColumn)"/> 
				ON 
				<xsl:call-template name="ident">
					<xsl:with-param name="name" select="../@name"/>
				</xsl:call-template> 
				( <xsl:call-template name="ident"/> ); 
			</item>
		</xsl:if>
	</xsl:template>

	<xsl:template match="a:SimpleType|a:PrimitiveType">
		<!-- We do nothing for these types other than simply consume and ignore them. -->
	</xsl:template>
		
	<xsl:template match="a:Enumerated">
		<!-- a foreign key column for a reference table -->
		<decorate>
			<xsl:call-template name="annotate" />
			<item>
				<xsl:call-template name="ident"/>
				VARCHAR(50)
				<xsl:call-template name="notnull"/>
			</item>
		</decorate>
	</xsl:template>
	
	<xsl:template match="a:Enumerated" mode="constraints">
		<item>
			ALTER TABLE
			<xsl:call-template name="ident">
				<xsl:with-param name="name" select="../@name"/>
			</xsl:call-template>
			ADD FOREIGN KEY ( <xsl:call-template name="ident"/> ) 
			REFERENCES 
   			<xsl:call-template name="ident">
				<xsl:with-param name="name" select="@name"/>
			</xsl:call-template> 
			( "name" );
		</item> 
	</xsl:template>

	<xsl:template match="a:Simple|a:Domain">
		<!-- a simple column  -->
		<xsl:if test="not(@maxOccurs = 'unbounded') and @maxOccurs &lt;= 1 and @name != 'mRID'">
			<decorate>
				<xsl:call-template name="annotate" />
				<item>
					<xsl:call-template name="ident"/>
					<xsl:call-template name="type"/>
					<xsl:call-template name="notnull"/>
				</item>
			</decorate>
		</xsl:if>
	</xsl:template>

	<xsl:template name="annotate">
		<!--  generate and annotation -->
		<list indent="-- ">
			<xsl:apply-templates mode="annotate"/>
		</list>
	</xsl:template>

	<xsl:template match="a:Comment|a:Note" mode="annotate">
		<!--  generate human readable annotation -->
		<wrap width="70">
			<xsl:value-of select="."/>
		</wrap>
	</xsl:template>

	<xsl:template match="text()">
		<!--  dont pass text through  -->
	</xsl:template>

	<xsl:template match="node()" mode="inheritance-constraints">
		<!-- dont pass any defaults in inheritance-constraints mode -->
	</xsl:template>
	
	<xsl:template match="node()" mode="constraints">
		<!-- dont pass any defaults in constraints mode -->
	</xsl:template>
	
	<xsl:template match="node()" mode="cascade-constraints">
		<!-- dont pass any defaults in constraints mode -->
	</xsl:template>
	
	<xsl:template match="node()" mode="fk-indexes">
		<!-- dont pass any defaults in fk-indexes mode -->
	</xsl:template>

	<xsl:template match="node()" mode="annotate">
		<!-- dont pass any defaults in annotate mode -->
	</xsl:template>

</xsl:stylesheet>
